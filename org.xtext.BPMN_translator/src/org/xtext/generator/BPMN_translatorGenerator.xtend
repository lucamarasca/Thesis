/*
 * generated by Xtext 2.23.0
 */
package org.xtext.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.bPMN_translator.*
import java.util.ArrayList

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class BPMN_translatorGenerator extends AbstractGenerator {
//++++++++++++++++++++++++++++++Costants++++++++++++++++++++++++++++++++++
ArrayList<String> task_type;
ArrayList<String> gateway_type;
String app;
Resource r;
int i;
String incoming_arrow;
String outgoing_arrow;
	
	String return_value
	
def Initialize(Resource resource){
	FillTaskType();
	FillGatewayType();
	r=resource
}

def FillTaskType(){
	task_type = new ArrayList<String>();
	task_type.addAll("task","sendTask", "receiveTask" , "userTask",
		"manualTask" , "businessRuleTask" , "serviceTask" , "scriptTask" , 
		"callActivity"
	);
}

def FillGatewayType(){
	gateway_type = new ArrayList<String>();
	gateway_type.addAll("exclusiveGateway" , "parallelGateway", "inclusiveGateway",
		"complexGateway", "eventBasedGateway"
	);
}
//++++++++++++++++++++++++++++++Generation++++++++++++++++++++++++++++++++
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		Initialize(resource);
		//Main file generation
		fsa.generateFile("Main.ino", StaticMainFileStart() + '''
        «FOR element : resource.allContents.filter(element).toIterable»	         
	        	«GenerateMainFile(element)»     	       
        «ENDFOR»
        ''' + StaticMainFileEnd())
		//.h lib file generation
		fsa.generateFile("GeneratedLib.h" , StaticLibHStart() + '''
        «FOR element : resource.allContents.filter(element).toIterable»
	        «FOR Open : element.open» 
	        	«TaskToMethodsH(Open)»     
	        «ENDFOR»
        «ENDFOR»
        ''' + StaticLibHEnd())
        //.cpp lib file generation
        fsa.generateFile("GeneratedLib.cpp" , StaticLibCPPStart() + '''
        «FOR element : resource.allContents.filter(element).toIterable»
	        «FOR Open : element.open»         
	        	«TaskToMethodsCPP(Open)»     
	        «ENDFOR»
        «ENDFOR»
        ''')
		        
	}
	
	def TaskToMethodsH(Open open_tag){
		val type = "void";
		
		if(task_type.contains(open_tag.keywords.get(0))){
			
			return "\t" + type + " " + open_tag.value.get(getNamePosition(open_tag))
			.replaceAll(" ", "_").toLowerCase() + "();"
		}
		
	}
	def TaskToMethodsCPP(Open open_tag){
		val type = "void";
		
		if(task_type.contains(open_tag.keywords.get(0))){
			
			return type + " MyBPMNClass::" + open_tag.value.get(getNamePosition(open_tag))
			.replaceAll(" ", "_").toLowerCase() + "()\n{\n\n\t\\\\todo\n\n}\n"
		}
		
	}
	def GenerateMainFile(element e){
		
		
		
		app = ""
		
		//outgoing_arrow = getOutgoingArrowId(e)
				
		if(gateway_type.contains(getTaskType(e).toString()))
		{	
			'''	
			«FOR element : r.allContents.filter(element).toIterable»	         
	        	«getOutgoingArrow(element, getTaskId(e))»     	       
        	«ENDFOR»
			'''
		}
			
		
		
		
			
	}
	
	
	
//+++++++++++++++++++++++++++++++GETERS++++++++++++++++++++++++++++++++
def getOutgoingArrow(element e, CharSequence app){
		return_value = "" 
	
		i=0;
		for (Open : e.open)
		{
			if (Open.keywords.get(0).equals("sequenceFlow"))
			{
				for (keywords : Open.keywords1)
				{
					if( keywords.equals("sourceRef"))
						return_value += Open.value.get(i).toString()
					i++
				}
			}
		}
		return return_value
	}
def write(Object o){
	'''«o»'''
}
	//return the task type
	def getTaskType(element e){		 
'''«FOR Open : e.open»«Open.keywords.get(0)»«ENDFOR»'''
	}
	//return the id of an task
	def getTaskId(element e){		 
'''«FOR Open : e.open»«Open.value»«ENDFOR»'''
	}
	
	
//+++++++++++++++++++++++++++++++++OTHER METHODS++++++++++++++++++++++++++++++++++++
def int getNamePosition(Open open_tag){
	return open_tag.keywords1.lastIndexOf("name");
}	
	
//++++++++++++++++++++++++++++++++STATIC PART OF THE GENERATED CODE++++++++++++++++++++++++++++++++++++	
def StaticLibHStart(){
	return
	"
#include \"Arduino.h\"        //includes the library Arduino.h
#include \"SoftwareSerial.h\" //Includes the library SoftwareSerial.h
//Used for defining static variables
enum {
	//rate of trnsmission
	BAUND_RATE = 9600,
};
class MyBPMNClass {
"
}

def StaticLibHEnd(){
	return "}"
}

def StaticLibCPPStart(){
	return 
"
#include <GeneratedLib.h>\n
"
}



def StaticMainFileStart(){
	return 
	"
#include <GeneratedLib.h>

void setup()
{
  Serial.begin(9600); // opens serial port, sets data rate to 9600 bps

  while (!Serial)
    ;

		";
}
def StaticMainFileEnd(){
return 
"
}

void loop()
{

}
"
}
	
}

/*
 * generated by Xtext 2.23.0
 */
package org.xtext.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.bPMN_translator.*

import java.util.ArrayList
import javax.swing.text.html.parser.Entity

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class BPMN_translatorGenerator extends AbstractGenerator {
//++++++++++++++++++++++++++++++Costants++++++++++++++++++++++++++++++++++
ArrayList<String> task_type;
ArrayList<String> gateway_type;
String app;
Resource r;
int i;
String incoming_arrow;
String outgoing_arrow;
SensorsCodeGenerator s;
ArduinoCPPCodeGenerator cpp_gen;
DefineCodeGenerator define;
	
	String return_value
	
def Initialize(Resource resource){
	FillTaskType();
	FillGatewayType();
	setDatas(resource);
	r=resource
}

def FillTaskType(){
	task_type = new ArrayList<String>();
	task_type.addAll("task","sendTask", "receiveTask" , "userTask",
		"manualTask" , "businessRuleTask" , "serviceTask" , "scriptTask" , 
		"callActivity"
	);
}

def FillGatewayType(){
	gateway_type = new ArrayList<String>();
	gateway_type.addAll("exclusiveGateway" , "parallelGateway", "inclusiveGateway",
		"complexGateway", "eventBasedGateway"
	);
}
//++++++++++++++++++++++++++++++Generation++++++++++++++++++++++++++++++++
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		
		if (resource !== null)
		{
			
			//THIS MEANS THAT I'VE SELECTED A BPMN
			Initialize(resource);
			//Main file generation
			fsa.generateFile("Main.ino", StaticMainFileStart() + StaticMainFileEnd())
			//.h lib file generation
			fsa.generateFile("GeneratedLib.h" , StaticLibHStart() + StaticLibHEnd())
	        //.cpp lib file generation
	        fsa.generateFile("GeneratedLib.cpp" ,ArduinoGenerationCodeCPP())
	        
	        
        }
        else
        {
        	//THIS MEANS THAT NO SOURCE BPMN HAS BEEN SELECTED
        	//I need to generate generic code using my datas
        	
			//Main file generation
			fsa.generateFile("Main.ino", StaticMainFileStart() + StaticMainFileEnd())
			
			//.h lib file generation
			fsa.generateFile("GeneratedLib.h" , StaticLibHStart() +
				ArduinoCodeGenerationH() +
				StaticLibHEnd())

	        //.cpp lib file generation
	        fsa.generateFile("GeneratedLib.cpp" ,ArduinoGenerationCodeCPP())
        }
        
       
		        
	}
	
//library.h
def ArduinoCodeGenerationH(){
	define = new DefineCodeGenerator(Parameters.selected_sensor,Parameters.selected_protocol,Parameters.selected_wifisensor);
	define.generateHCode();
}	

//library.cpp
def ArduinoGenerationCodeCPP(){
	cpp_gen = new ArduinoCPPCodeGenerator(Parameters.selected_device , Parameters.selected_protocol, Parameters.selected_wifisensor, Parameters.selected_sensor); 
	return cpp_gen.Generation();
}

def setDatas(Resource r){
	setNetworkProtocolDatas(r);
}

def setNetworkProtocolDatas(Resource r){
	for (Element : r.allContents.toIterable.filter(element))
	{
		for(Content : Element.contents)
		{
			for(Codex : Content.codex)
			{
				for(Device : Codex.device_code)
					System.out.println("DEVICE=" + Device.device);
			}
		}
	}
}
//++++++++++++++++++++++++++++++++STATIC PART OF THE GENERATED CODE++++++++++++++++++++++++++++++++++++	
def StaticLibHStart(){
	return
	"
#include \"Arduino.h\"        //includes the library Arduino.h
#include \"SoftwareSerial.h\" //Includes the library SoftwareSerial.h \n
"
}

def StaticLibHEnd(){
	return "}"
}





def StaticMainFileStart(){
	return 
	"#include <GeneratedLib.h>\n" +
	"void setup()\n" +
	"{" +
  		"\tSerial.begin(9600);\n // opens serial port, sets data rate to 9600 bps"+

  		"\twhile (!Serial);";
    
}
def StaticMainFileEnd(){
return 
"
}
void loop()
{

}
"
}




//++++++++++++++++++++++++++++Comments+++++++++++++++++++++++++++++++++++++++
/*
 def TaskToMethodsH(Open open_tag){
		val type = "void";
		
		if(task_type.contains(open_tag.keywords.get(0))){
			
			return "\t" + type + " " + open_tag.value.get(getNamePosition(open_tag))
			.replaceAll(" ", "_").toLowerCase() + "();"
		}
		
	}
	def TaskToMethodsCPP(Open open_tag){
		val type = "void";
		
		if(task_type.contains(open_tag.keywords.get(0))){
			
			return type + " MyBPMNClass::" + open_tag.value.get(getNamePosition(open_tag))
			.replaceAll(" ", "_").toLowerCase() + "()\n{\n\n\t\\\\todo\n\n}\n"
		}
		
	}



//+++++++++++++++++++++++++++++++GETERS++++++++++++++++++++++++++++++++
def getOutgoingArrow(element e, CharSequence app){
		return_value = "" 
	
		i=0;
		for (Open : e.open)
		{
			if (Open.keywords.get(0).equals("sequenceFlow"))
			{
				for (keywords : Open.keywords1)
				{
					if( keywords.equals("sourceRef"))
						return_value += Open.value.get(i).toString()
					i++
				}
			}
		}
		return return_value
	}
def write(Object o){
	'''«o»'''
}
	//return the task type
	def getTaskType(element e){		 
'''«FOR Open : e.open»«Open.keywords.get(0)»«ENDFOR»'''
	}
	//return the id of an task
	def getTaskId(element e){		 
'''«FOR Open : e.open»«Open.value»«ENDFOR»'''
	}
	
	
//+++++++++++++++++++++++++++++++++OTHER METHODS++++++++++++++++++++++++++++++++++++
def int getNamePosition(Open open_tag){
	return open_tag.keywords1.lastIndexOf("name");
}	 */	
}

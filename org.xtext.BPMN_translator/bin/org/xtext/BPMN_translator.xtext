grammar org.xtext.BPMN_translator with org.eclipse.xtext.common.Terminals

generate bPMN_translator "http://www.xtext.org/BPMN_translator"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Model:
	
	  model += Xml
;



Xml:
	{Xml}  prolog? prova+=element*
	//{Xml} opening_tag += (Opening)
;

prolog:
	"<?" HEAD "version=" STRING "encoding="STRING "?>"
;

element     :   (open += Open 
				contents+=content close_tag+=Close)
            |  	singleton_tag+=Singleton
            ;

content:
	{content}
	( type += ("_TASK"|"_GATEWAY") "{" codex += codex "}"| element+=element | body+=preconditions*  body+=(BODY |variables) body+= conditions* |   keywords+=KEYWORDS  |  data+=STRING  )*
;

Open:
	
	 ("<" head+= HEAD ":" keywords += KEYWORDS  ((head1 += HEAD ":") | ((head1 += HEAD|keywords1 += KEYWORDS) "=" value+=STRING))* ">")
	 
	 
;

Singleton:
	{Singleton} ("<" HEAD ":" keywords+=KEYWORDS  ((HEAD ":") | (keywords1+= KEYWORDS "=" value+=STRING))*)  
	"/>"
;

Close:

	{Close} ("</" HEAD ":" KEYWORDS  ">") 
;
//+++++++++++++++MY GRAMMAR +++++++++++++++   
variables:
	("TEMPERATURE" "[" BODY "," BODY "]") 
;
conditions:
	("&lt;" | "&le;" | "&ge;" | "&gt;" | "=" | "&&" | "||" | ")")
;
preconditions:
	("!"|"(")
;
codex:
	  ( device_code += device protocol += protocol* sensor_code += sensor* ) 
	  
;
device:
	"DEVICE" ":" device += STRING
	"NAMEID" ":" id += STRING
;
protocol:
	 ((pname += ("MQTT") ) "{" (mqtt_data += mqtt_data
	 	mqtt_device += mqtt_device) "}")
;
mqtt_data:
	{mqtt_data}
	("NAME" "="  pname+=STRING |  "BROKER_USER" "=" broker_user+=STRING 
		| "BROKER_PASSWORD" "=" broker_password+=STRING | "BROKER" "=" broker += STRING
		| "NETWORK" "{" mqtt_network_data += mqtt_network_data* "}" 
		| "SUBTOPICS" "{" ("TOPIC_NAME" "=" subtopics += STRING)* "}" 
		| "PUBTOPICS" "{" ("TOPIC_NAME" "=" pubtopics += STRING* 
		| "DATA" "=" value+=(STRING))*"}"
	)*
;

mqtt_network_data:
	"SSID" "=" ssid+=STRING
	"PASSWORD" "=" password+=STRING
;
mqtt_device:
	"PROTOCOL_DEVICE" "{" "NAME" "=" dname += STRING "}"
;

sensor:
	
	(sname += "TEMPERATURE" "{" sensor += sensor_data "}")|
	(sname += "DISTANCE" "{" sensor += sensor_data "}")
;
sensor_data:
	{sensor_data}("NAME" "="  pname+=STRING 
		| "PINS" "=" pins+=STRING | "SENSOR_ID" "=" sensor_id += STRING
	)*
;

//++++++++++++++++END MY GRAMMAR+++++++++++++++++++
terminal HEAD:
	("bpmn"|"bpmndi"|"camunda"|"xsi"|"xml"|"xmlns"|"dc"|"di")
;




terminal KEYWORDS: "id" | "name" |  "isExecutable" | "sourceRef" | "processRef" | "targetRef" 
	| "calledElement" | "type" | "expression" | "value" | "resultVariable" | "asyncBefore" | "intermediateThrowEvent"
	| "class" | "event" | "startEvent"| "task" | "messageEventDefinition" | "sequenceFlow" | "isExpanded"
	| "condition" | "association" | "outgoing" | "serviceTask" | "process" | "standardLoopCharacteristics"
	| "incoming" | "intermediateCatchEvent" | "conditionalEventDefinition"|"isMarkerVisible" | "terminateEventDefinition"
	| "endEvent" | "textAnnotation" | "text" | "dataStoreReference" | "bpmnElement" | "dataObjectReference"
	| "callActivity" | "laneSet" | "lane" | "flowNodeRef" |"definitions" | "userTask" | "documentation"
	| "dataOutputAssociation" | "exclusiveGateway" | "waypoint" | "BPMNLabel" | "diagramRelationId"
	| "extensionElements" | "inputOutput" | "list" | "inputParameter" | "height" | "messageFlow" | "dataObjectRef"
	| "outputParameter" |  "properties" | "property" | "BPMNShape" | "Bounds" | "subProcess" | "cancelActivity"
	| "field" | "string" | "scriptTask" | "script" |"BPMNPlane" | "BPMNEdge" | "sendTask" | "boundaryEvent"
	| "executionListener" | "timerEventDefinition" | "timeDuration" | "width" | "dataInputAssociation"
	| "parallelGateway" | "collaboration" | "participant" | "targetNamespace" | "dataObject" | "signalEventDefinition"
	| "BPMNDiagram"		| "exporter" | "exporterVersion" | "x" | "y"| "isHorizontal" | "attachedToRef"
	| "conditionExpression" | "receiveTask" | "messageRef" | "initiator" | "message";


terminal BODY returns ecore::EString : ('a'..'z'|'A'..'Z'|'è'|'ò'|INT|'_')* ;


/*
 * generated by Xtext 2.23.0
 */
package org.xtext.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.xtext.bPMN_translator.BPMN_translatorPackage;
import org.xtext.bPMN_translator.Close;
import org.xtext.bPMN_translator.Model;
import org.xtext.bPMN_translator.Open;
import org.xtext.bPMN_translator.Singleton;
import org.xtext.bPMN_translator.Xml;
import org.xtext.bPMN_translator.codex;
import org.xtext.bPMN_translator.content;
import org.xtext.bPMN_translator.device;
import org.xtext.bPMN_translator.element;
import org.xtext.bPMN_translator.element_value;
import org.xtext.bPMN_translator.mqtt_device;
import org.xtext.bPMN_translator.mqtt_network_data;
import org.xtext.bPMN_translator.protocol;
import org.xtext.bPMN_translator.protocol_data;
import org.xtext.bPMN_translator.sensor;
import org.xtext.bPMN_translator.sensor_data;
import org.xtext.services.BPMN_translatorGrammarAccess;

@SuppressWarnings("all")
public class BPMN_translatorSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private BPMN_translatorGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == BPMN_translatorPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case BPMN_translatorPackage.CLOSE:
				sequence_Close(context, (Close) semanticObject); 
				return; 
			case BPMN_translatorPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case BPMN_translatorPackage.OPEN:
				sequence_Open(context, (Open) semanticObject); 
				return; 
			case BPMN_translatorPackage.SINGLETON:
				sequence_Singleton(context, (Singleton) semanticObject); 
				return; 
			case BPMN_translatorPackage.XML:
				sequence_Xml(context, (Xml) semanticObject); 
				return; 
			case BPMN_translatorPackage.CODEX:
				sequence_codex(context, (codex) semanticObject); 
				return; 
			case BPMN_translatorPackage.CONTENT:
				sequence_content(context, (content) semanticObject); 
				return; 
			case BPMN_translatorPackage.DEVICE:
				sequence_device(context, (device) semanticObject); 
				return; 
			case BPMN_translatorPackage.ELEMENT:
				sequence_element(context, (element) semanticObject); 
				return; 
			case BPMN_translatorPackage.ELEMENT_VALUE:
				sequence_element(context, (element_value) semanticObject); 
				return; 
			case BPMN_translatorPackage.MQTT_DEVICE:
				sequence_mqtt_device(context, (mqtt_device) semanticObject); 
				return; 
			case BPMN_translatorPackage.MQTT_NETWORK_DATA:
				sequence_mqtt_network_data(context, (mqtt_network_data) semanticObject); 
				return; 
			case BPMN_translatorPackage.PROTOCOL:
				sequence_protocol(context, (protocol) semanticObject); 
				return; 
			case BPMN_translatorPackage.PROTOCOL_DATA:
				sequence_mqtt_data(context, (protocol_data) semanticObject); 
				return; 
			case BPMN_translatorPackage.SENSOR:
				sequence_sensor(context, (sensor) semanticObject); 
				return; 
			case BPMN_translatorPackage.SENSOR_DATA:
				sequence_sensor_data(context, (sensor_data) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Close returns Close
	 *
	 * Constraint:
	 *     {Close}
	 */
	protected void sequence_Close(ISerializationContext context, Close semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     model+=Xml
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Open returns Open
	 *
	 * Constraint:
	 *     (head+=HEAD keywords+=KEYWORDS (head1+=HEAD? ((head1+=HEAD | keywords1+=KEYWORDS) value+=STRING)?)+)
	 */
	protected void sequence_Open(ISerializationContext context, Open semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Singleton returns Singleton
	 *
	 * Constraint:
	 *     value+=STRING*
	 */
	protected void sequence_Singleton(ISerializationContext context, Singleton semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Xml returns Xml
	 *
	 * Constraint:
	 *     prova+=element*
	 */
	protected void sequence_Xml(ISerializationContext context, Xml semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     codex returns codex
	 *
	 * Constraint:
	 *     (device_code+=device protocol+=protocol* sensor_code+=sensor*)
	 */
	protected void sequence_codex(ISerializationContext context, codex semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     content returns content
	 *
	 * Constraint:
	 *     (codex+=codex | element+=element | body+=BODY | keywords+=KEYWORDS | data+=STRING)*
	 */
	protected void sequence_content(ISerializationContext context, content semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     device returns device
	 *
	 * Constraint:
	 *     device+=STRING
	 */
	protected void sequence_device(ISerializationContext context, device semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     element returns element
	 *
	 * Constraint:
	 *     (open+=Open contents+=content close_tag+=Close)
	 */
	protected void sequence_element(ISerializationContext context, element semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     element returns element_value
	 *
	 * Constraint:
	 *     singleton_tag+=Singleton
	 */
	protected void sequence_element(ISerializationContext context, element_value semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     mqtt_data returns protocol_data
	 *
	 * Constraint:
	 *     (
	 *         pname+=STRING | 
	 *         broker_user+=STRING | 
	 *         broker_password+=STRING | 
	 *         broker+=STRING | 
	 *         mqtt_network_data+=mqtt_network_data | 
	 *         topics+=STRING
	 *     )*
	 */
	protected void sequence_mqtt_data(ISerializationContext context, protocol_data semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     mqtt_device returns mqtt_device
	 *
	 * Constraint:
	 *     protocol_device+=mqtt_sensor_data
	 */
	protected void sequence_mqtt_device(ISerializationContext context, mqtt_device semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     mqtt_network_data returns mqtt_network_data
	 *
	 * Constraint:
	 *     (ssid+=STRING password+=STRING)
	 */
	protected void sequence_mqtt_network_data(ISerializationContext context, mqtt_network_data semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     protocol returns protocol
	 *
	 * Constraint:
	 *     (mqtt_data+=mqtt_data mqtt_device+=mqtt_device)
	 */
	protected void sequence_protocol(ISerializationContext context, protocol semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     sensor_data returns sensor_data
	 *
	 * Constraint:
	 *     (pname+=STRING | type+=STRING | pins+=STRING)*
	 */
	protected void sequence_sensor_data(ISerializationContext context, sensor_data semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     sensor returns sensor
	 *
	 * Constraint:
	 *     sensor+=sensor_data
	 */
	protected void sequence_sensor(ISerializationContext context, sensor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
